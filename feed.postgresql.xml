<?xml version="1.0" encoding="UTF-8"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
 <channel>
  <title> - postgresql</title>
  <description>Posts tagged as 'postgresql'</description>
  <atom:link href="http://hunleyd.github.io/feed.postgresql.xml" rel="self" type="application/rss+xml" />
  <link>http://hunleyd.github.io/tag/postgresql/</link>
  <updated>2016-11-30T12:22:31-05:00</updated>
  <author>
   <name></name>
   <email></email>
  </author>

  
   <item>
    <title>EXPLAINing intermittent perf problems</title>
    <description>&lt;p&gt;&lt;img src=&quot;http://i0.kym-cdn.com/entries/icons/original/000/010/997/35s7cv.jpg&quot; border=0 align=left style=&quot;PADDING-RIGHT: 5px&quot;&gt;We&amp;#39;ve all gotten the dreaded email/call from a user stating that a query is &amp;quot;slow sometimes&amp;quot;. If you&amp;#39;re lucky, the &amp;quot;sometimes&amp;quot; actually ends up being fairly consistent and you can fairly easily determine what&amp;#39;s happening (an errant cron job, for example). All too often though, the issue really is sporadic, fleeting, and indeterministic. So how do you track these down? And more importantly what do you do about them once found?&lt;/p&gt;

&lt;p&gt;For starters, you as the DBA should have your PostgreSQL logging configured to log these slow performing queries. After all, you and the devs and the users can agree that all queries should complete in some measure of time (1 sec, 1 minute, etc). So, once you know what this acceptable elapsed time is, you can easily log any query that runs longer by just setting this in your &lt;code&gt;postgresql.conf&lt;/code&gt;:&lt;/p&gt;
&lt;figure class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-text&quot; data-lang=&quot;text&quot;&gt;log_min_duration_statement = 1000   # log anything running longer than 1s
&lt;/code&gt;&lt;/pre&gt;&lt;/figure&gt;
&lt;p&gt;And now, you have all queries with long run times logged automatically. And these show up nicely in your pgBadger reports too!&lt;/p&gt;

&lt;p&gt;If you&amp;#39;re lucky, you&amp;#39;ll be able to use &lt;code&gt;EXPLAIN&lt;/code&gt; to see why the query is behaving poorly. However, if your life is like mine, the explain plan will be reasonable and won&amp;#39;t have any smoking guns to speak of. Which means the performance is either load dependent or being influenced by other processes (something is blowing out your caches, for example). In these cases, what you really need is the &lt;code&gt;EXPLAIN&lt;/code&gt; output from the very instant that it performed poorly. However, you can&amp;#39;t go back in time to get it. But what you can do is make use of the &lt;code&gt;auto_explain&lt;/code&gt; module that ships with PostgreSQL.&lt;/p&gt;

&lt;p&gt;In case the name wasn&amp;#39;t obvious enough, the &lt;code&gt;auto_explain&lt;/code&gt; module causes PostgreSQL to automatically run &lt;code&gt;EXPLAIN&lt;/code&gt; on queries according to thresholds that you configure. These automatically generated plans are then logged into the normal PostgreSQL logs. Let&amp;#39;s walk through setting it up and see how it works.&lt;/p&gt;

&lt;p&gt;First, in your &lt;code&gt;postgresql.conf&lt;/code&gt; we want to enable the module:&lt;/p&gt;
&lt;figure class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-text&quot; data-lang=&quot;text&quot;&gt;shared_preload_libraries = &amp;#39;auto_explain&amp;#39;  # change requires restart
&lt;/code&gt;&lt;/pre&gt;&lt;/figure&gt;
&lt;p&gt;As stated, you will have to restart the postmaster to get the module to load. However, let&amp;#39;s configure it in &lt;code&gt;postgresql.conf&lt;/code&gt; first:&lt;/p&gt;
&lt;figure class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-text&quot; data-lang=&quot;text&quot;&gt;# Add settings for extensions here
#
# auto_explain
# http://www.postgresql.org/docs/current/static/auto-explain.html
auto_explain.log_analyze = true
auto_explain.log_timing = true
auto_explain.log_verbose = true
auto_explain.log_min_duration = &amp;#39;1000ms&amp;#39;
auto_explain.log_nested_statements = true
auto_explain.log_buffers = true
# auto_explain
&lt;/code&gt;&lt;/pre&gt;&lt;/figure&gt;
&lt;p&gt;What we&amp;#39;ve done here is configure &lt;code&gt;auto_explain&lt;/code&gt; to&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;use &lt;code&gt;EXPLAIN ANALYZE&lt;/code&gt;&lt;sup&gt;1&lt;/sup&gt;&lt;/li&gt;
&lt;li&gt;to use the &lt;code&gt;TIMING&lt;/code&gt; option of &lt;code&gt;EXPLAIN&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;to use the &lt;code&gt;VERBOSE&lt;/code&gt; option of &lt;code&gt;EXPLAIN&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;to log the plan for anything running longer than 1 second (matches &lt;code&gt;log_min_duration_statement&lt;/code&gt;, above)&lt;/li&gt;
&lt;li&gt;to include statements inside a function to also be logged&lt;/li&gt;
&lt;li&gt;to use the &lt;code&gt;BUFFERS&lt;/code&gt; option of &lt;code&gt;EXPLAIN&lt;/code&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;As with most &lt;code&gt;GUC&lt;/code&gt; in PostgreSQL, these can all be changed using &lt;code&gt;SET&lt;/code&gt; in a given session, but we&amp;#39;re setting the defaults here. Now that we have them setup, let&amp;#39;s see what it looks like in practice.&lt;/p&gt;
&lt;figure class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-sql&quot; data-lang=&quot;sql&quot;&gt;(doug@[local]:5432/doug[28838]) # CREATE TABLE x(t text);
CREATE TABLE
Time: 6.022 ms
(doug@[local]:5432/doug[28838]) # INSERT INTO x(t) SELECT generate_series(1,10000);
INSERT 0 10000
Time: 23.565 ms
(doug@[local]:5432/doug[28838]) #
&lt;/code&gt;&lt;/pre&gt;&lt;/figure&gt;
&lt;p&gt;We connected to PostgreSQL, created a test table, and then used &lt;code&gt;generate_series&lt;/code&gt; to insert 10k rows. In our logs, the following were added:&lt;/p&gt;
&lt;figure class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-text&quot; data-lang=&quot;text&quot;&gt;2016-11-28 13:20:30 EST [28838]: [18-1] user=doug,db=doug,app=psql,client=[local] LOG:  duration: 33.987 ms  statement: CREATE TABLE x(t text);
2016-11-28 13:20:59 EST [28838]: [19-1] user=doug,db=doug,app=psql,client=[local] LOG:  duration: 16.461 ms  plan:
  Query Text: INSERT INTO x(t) SELECT generate_series(1,10000);
  Insert on public.x  (cost=0.00..50.02 rows=1000 width=32) (actual time=16.459..16.459 rows=0 loops=1)
    Buffers: shared hit=10085 read=47 dirtied=45
    I/O Timings: read=0.012
    -&amp;gt;  Subquery Scan on &amp;quot;*SELECT*&amp;quot;  (cost=0.00..50.02 rows=1000 width=32) (actual time=0.010..4.755 rows=10000 loops=1)
          Output: &amp;quot;*SELECT*&amp;quot;.generate_series
          -&amp;gt;  Result  (cost=0.00..15.02 rows=1000 width=4) (actual time=0.007..1.364 rows=10000 loops=1)
                Output: generate_series(1, 10000)
2016-11-28 13:20:59 EST [28838]: [20-1] user=doug,db=doug,app=psql,client=[local] LOG:  duration: 23.374 ms  statement: INSERT INTO x(t) SELECT generate_series(1,10000);
2016-11-28 13:21:00 EST [30079]: [1-1] user=,db=,app=,client= LOG:  automatic analyze of table &amp;quot;doug.public.x&amp;quot; system usage: CPU 0.00s/0.11u sec elapsed 0.14 sec
&lt;/code&gt;&lt;/pre&gt;&lt;/figure&gt;
&lt;p&gt;(Note that for illustrative purposes, I issued &lt;code&gt;SET auto_explain.log_min_duration = &amp;#39;0ms&amp;#39;&lt;/code&gt;)&lt;/p&gt;

&lt;p&gt;So, you can see that the &lt;code&gt;CREATE TABLE&lt;/code&gt; didn&amp;#39;t log anything through the &lt;code&gt;auto_explain&lt;/code&gt; module, but the &lt;code&gt;INSERT INTO&lt;/code&gt; did. This is a boring example, so let&amp;#39;s try a &lt;code&gt;SELECT&lt;/code&gt; against our table:&lt;/p&gt;
&lt;figure class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-sql&quot; data-lang=&quot;sql&quot;&gt;(doug@[local]:5432/doug[28838]) # SELECT * FROM x ORDER BY t LIMIT 10;
‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê
‚îÇ   t   ‚îÇ
‚îú‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚î§
‚îÇ 1     ‚îÇ
‚îÇ 10    ‚îÇ
‚îÇ 100   ‚îÇ
‚îÇ 1000  ‚îÇ
‚îÇ 10000 ‚îÇ
‚îÇ 1001  ‚îÇ
‚îÇ 1002  ‚îÇ
‚îÇ 1003  ‚îÇ
‚îÇ 1004  ‚îÇ
‚îÇ 1005  ‚îÇ
‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò
(10 rows)

Time: 11.982 ms
&lt;/code&gt;&lt;/pre&gt;&lt;/figure&gt;
&lt;p&gt;and the logs look like:
&lt;code&gt;
2016-11-28 13:27:38 EST [322]: [7-1] user=,db=,app=,client= LOG:  checkpoint starting: time
2016-11-28 13:27:46 EST [322]: [8-1] user=,db=,app=,client= LOG:  checkpoint complete: wrote 75 buffers (0.0%); 0 transaction log file(s) added, 0 removed, 0 recycled; write=7.569 s, sync=0.092 s, total=7.920 s; sync files=23, longest=0.092 s, average=0.004 s; distance=685 kB, estimate=685 kB
2016-11-28 13:28:48 EST [28838]: [21-1] user=doug,db=doug,app=psql,client=[local] LOG:  duration: 11.120 ms  plan:
  Query Text: SELECT * FROM x ORDER BY t LIMIT 10;
  Limit  (cost=561.10..561.12 rows=10 width=4) (actual time=11.073..11.073 rows=10 loops=1)
    Output: t
    Buffers: shared hit=45
    -&amp;gt;  Sort  (cost=561.10..586.10 rows=10000 width=4) (actual time=11.072..11.072 rows=10 loops=1)
          Output: t
          Sort Key: x.t
          Sort Method: top-N heapsort  Memory: 25kB
          Buffers: shared hit=45
          -&amp;gt;  Seq Scan on public.x  (cost=0.00..345.00 rows=10000 width=4) (actual time=0.018..1.224 rows=10000 loops=1)
                Output: t
                Buffers: shared hit=45
2016-11-28 13:28:48 EST [28838]: [22-1] user=doug,db=doug,app=psql,client=[local] LOG:  duration: 11.813 ms  statement: SELECT * FROM x ORDER BY t LIMIT 10;
&lt;/code&gt;&lt;/p&gt;

&lt;p&gt;(You can safely ignore the checkpoint lines at the top there)&lt;/p&gt;

&lt;p&gt;There you have both the statement we ran, and the full &lt;code&gt;EXPLAIN&lt;/code&gt; plan. You can see we did a sequential scan on the table (looks like it was all in the &lt;code&gt;shared_buffers&lt;/code&gt; too) and then we passed that up to a &lt;code&gt;sort&lt;/code&gt; node for an in-memory sort, and then passed that result set up to the &lt;code&gt;limit&lt;/code&gt; node.&lt;/p&gt;

&lt;p&gt;While this is a stupid simple example, I hope you can see that having this in production for large, complicated queries will allow you to better diagnose issues. For example, simply doing a manual &lt;code&gt;EXPLAIN ANALYZE&lt;/code&gt; on the same query and seeing that you get a different plan is potentially enough to rule out (or in) certain culprits for the intermittent performance issue.
&lt;br&gt;
&lt;br&gt;
&lt;br&gt;
&lt;br&gt;
&lt;sup&gt;1&lt;/sup&gt; - This option causes the postmaster to collect info on &lt;em&gt;every&lt;/em&gt; statement executed, even if &lt;code&gt;auto_explain&lt;/code&gt; isn&amp;#39;t going to log it. It has a measurable impact on overall performance. Please test on your workload and decide for yourself if the overhead is worth the trade-off&lt;/p&gt;
</description>
    <link>http://hunleyd.github.io/EXPLAINing-intermittent-perf-problems/ </link>
    <pubDate>2016-11-28T07:24:12-05:00</pubDate>
    <guid isPermaLink="true">http://hunleyd.github.io/EXPLAINing-intermittent-perf-problems/</guid>
   </item>
  
   <item>
    <title>PostgreSQL logging, strftime, and you</title>
    <description>&lt;p&gt;&lt;img src=&quot;http://www.metasource.com/images/content/data-processing-image.jpg&quot; border=0 align=right height=200 width=200 style=&quot;PADDING-LEFT: 5px&quot;&gt;PostgreSQL has a pretty extensive logging facility. I&amp;#39;ve talked briefly about configuring it to get the most out of pgBadger before, but today I&amp;#39;m gonna talk a bit about the naming of the log file itself. The chosen filename doesn&amp;#39;t have to be static. You can, in fact, have the name dynamically created by using strftime() escapes. But what exactly are those?&lt;/p&gt;
&lt;figure class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-text&quot; data-lang=&quot;text&quot;&gt;    The strftime() function formats the information from timeptr into the buffer s,
    according to the string pointed to by format.

    The format string consists of zero or more conversion specifications and ordi-
    nary characters.  All ordinary characters are copied directly into the buffer.
    A conversion specification consists of a percent sign ```%&amp;#39;&amp;#39;&amp;#39; and one other
    character.
&lt;/code&gt;&lt;/pre&gt;&lt;/figure&gt;
&lt;p&gt;Say what? Essentially, given a timestamp and a format specification, you&amp;#39;ll get the timestamp back in a different formatted output. So what are these format specifications? Well, they are defined by your systems &lt;code&gt;libc&lt;/code&gt; implementation. On Linux, this is (typically) glibc, whereas on OSX and the BSDs, it&amp;#39;s BSD libc. You really shouldn&amp;#39;t see a difference between these two, but it could happen. On macOS Sierra, they are (for the examples below, we&amp;#39;ll use today&amp;#39;s date of Monday, November 21, 2016 with a timestamp of 1pm EST):&lt;/p&gt;
&lt;figure class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-apache&quot; data-lang=&quot;apache&quot;&gt;    %A    is replaced by national representation of the full weekday name (&amp;quot;Monday&amp;quot;)
    %a    is replaced by national representation of the abbreviated weekday name (&amp;quot;Mon&amp;quot;)
    %B    is replaced by national representation of the full month name (&amp;quot;November&amp;quot;)
    %b    is replaced by national representation of the abbreviated month name (&amp;quot;Nov&amp;quot;)
    %C    is replaced by (year / 100) as decimal number; single digits are preceded by a zero (&amp;quot;20&amp;quot;)
    %c    is replaced by national representation of time and date (&amp;quot;Mon Nov 21 13:00:00 2016&amp;quot;)
    %D    is equivalent to ``%m/%d/%y&amp;#39;&amp;#39; (&amp;quot;11/21/16&amp;quot;)
    %d    is replaced by the day of the month as a decimal number (01-31) (&amp;quot;21&amp;quot;)
    %e    is replaced by the day of the month as a decimal number (1-31); single digits are preceded by a blank (&amp;quot;21&amp;quot;)
    %F    is equivalent to ``%Y-%m-%d&amp;#39;&amp;#39; (&amp;quot;2016-11-21&amp;quot;)
    %G    is replaced by a year as a decimal number with century.  This year is the one that contains the greater part of the week (Monday as the first day of the week) (&amp;quot;2016&amp;quot;)
    %g    is replaced by the same year as in ``%G&amp;#39;&amp;#39;, but as a decimal number without century (00-99) (&amp;quot;16&amp;quot;)
    %H    is replaced by the hour (24-hour clock) as a decimal number (00-23) (&amp;quot;12&amp;quot;)
    %h    the same as %b (&amp;quot;Nov&amp;quot;)
    %I    is replaced by the hour (12-hour clock) as a decimal number (01-12) (&amp;quot;12&amp;quot;)
    %j    is replaced by the day of the year as a decimal number (001-366) (&amp;quot;326&amp;quot;)
    %k    is replaced by the hour (24-hour clock) as a decimal number (0-23); single digits are preceded by a blank (&amp;quot;13&amp;quot;)
    %l    is replaced by the hour (12-hour clock) as a decimal number (1-12); single digits are preceded by a blank (&amp;quot; 1&amp;quot;)
    %M    is replaced by the minute as a decimal number (00-59) (&amp;quot;00&amp;quot;)
    %m    is replaced by the month as a decimal number (01-12) (&amp;quot;11&amp;quot;)
    %n    is replaced by a newline
    %p    is replaced by national representation of either &amp;quot;ante meridiem&amp;quot; (a.m.) or &amp;quot;post meridiem&amp;quot; (p.m.)  as appropriate (&amp;quot;PM&amp;quot;)
    %R    is equivalent to ``%H:%M&amp;#39;&amp;#39; (&amp;quot;13:00&amp;quot;)
    %r    is equivalent to ``%I:%M:%S %p&amp;#39;&amp;#39; (&amp;quot;01:00:00 PM&amp;quot;)
    %S    is replaced by the second as a decimal number (00-60) (&amp;quot;00&amp;quot;)
    %s    is replaced by the number of seconds since the Epoch, UTC (&amp;quot;1479751200&amp;quot;)
    %T    is equivalent to ``%H:%M:%S&amp;#39;&amp;#39; (&amp;quot;13:00:00&amp;quot;)
    %t    is replaced by a tab
    %U    is replaced by the week number of the year (Sunday as the first day of the week) as a decimal number (00-53) (&amp;quot;47&amp;quot;)
    %u    is replaced by the weekday (Monday as the first day of the week) as a decimal number (1-7) (&amp;quot;1&amp;quot;)
    %V    is replaced by the week number of the year (Monday as the first day of the week) as a decimal number (01-53).  If the week containing January 1 has four or more days in the new year, then it is week 1; otherwise it is the last week of the previous year, and the next week is week 1 (&amp;quot;47&amp;quot;)
    %v    is equivalent to ``%e-%b-%Y&amp;#39;&amp;#39; (&amp;quot;21-Nov-2016&amp;quot;)
    %W    is replaced by the week number of the year (Monday as the first day of the week) as a decimal number (00-53) (&amp;quot;47&amp;quot;)
    %w    is replaced by the weekday (Sunday as the first day of the week) as a decimal number (0-6) (&amp;quot;1&amp;quot;)
    %X    is replaced by national representation of the time (&amp;quot;13:00:00&amp;quot;)
    %x    is replaced by national representation of the date (&amp;quot;11/21/2016&amp;quot;)
    %Y    is replaced by the year with century as a decimal number (&amp;quot;2016&amp;quot;)
    %y    is replaced by the year without century as a decimal number (00-99) (&amp;quot;16&amp;quot;)
    %Z    is replaced by the time zone name (&amp;quot;EST&amp;quot;)
    %z    is replaced by the time zone offset from UTC; a leading plus sign stands for east of UTC, a minus sign for west of UTC, hours and minutes follow with two digits each and no delimiter between them (&amp;quot;-0500&amp;quot;)
    %%    is replaced by `%&amp;#39;
&lt;/code&gt;&lt;/pre&gt;&lt;/figure&gt;
&lt;p&gt;Phew! That was a lot wasn&amp;#39;t it? And where exactly does this come into play? As the &lt;code&gt;postgresql.conf&lt;/code&gt; says:&lt;/p&gt;
&lt;figure class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-text&quot; data-lang=&quot;text&quot;&gt;log_filename = &amp;#39;postgresql-%a.log&amp;#39;      # log file name pattern,
                                        # can include strftime() escapes
&lt;/code&gt;&lt;/pre&gt;&lt;/figure&gt;
&lt;p&gt;So, you can use any of the escapes above to craft a filename that automagically gets updated according to the current timestamp. In my example above, I&amp;#39;m getting PostgreSQL to create a new logfile with the local weekday abbreviation. So my &lt;code&gt;$PGDATA/pg_log&lt;/code&gt; directory will only ever contain:&lt;/p&gt;
&lt;figure class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-text&quot; data-lang=&quot;text&quot;&gt;postgresql-Sun.log postgresql-Mon.log postgresql-Tue.log
postgresql-Wed.log postgresql-Thu.log postgresql-Fri.log
postgresql-Sat.log
&lt;/code&gt;&lt;/pre&gt;&lt;/figure&gt;
&lt;p&gt;But wait! The key to all this is that &lt;em&gt;PostgreSQL only evaluates the filename when it first opens/creates the logfile&lt;/em&gt;. So, if you start your cluster on Mon and do not restart it and don&amp;#39;t have it configured to log rotate, you&amp;#39;ll still be writing to &lt;code&gt;postgresql-Mon.log&lt;/code&gt; forever. Fortunately, PostgreSQL has you covered here too:&lt;/p&gt;
&lt;figure class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-text&quot; data-lang=&quot;text&quot;&gt;log_rotation_age = 1d      # Automatic rotation of logfiles will
                           # happen after that time.  0 disables.
log_rotation_size = 10MB   # Automatic rotation of logfiles will
                           # happen after that much log output.
                           # 0 disables.
&lt;/code&gt;&lt;/pre&gt;&lt;/figure&gt;
&lt;p&gt;So, using my &lt;code&gt;log_filename&lt;/code&gt; from above, I enable &lt;code&gt;log_rotation_age&lt;/code&gt; (set to 1 day) and disable &lt;code&gt;log_rotation_size&lt;/code&gt; and I automatically get a new log every day. If I wanted hourly logs, I could do something like:&lt;/p&gt;
&lt;figure class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-text&quot; data-lang=&quot;text&quot;&gt;log_filename = &amp;#39;postgresql-%a-%H&amp;#39;
log_rotation_age = 1h
&lt;/code&gt;&lt;/pre&gt;&lt;/figure&gt;
&lt;p&gt;which would give me logs of &lt;code&gt;postgresql-Mon-00&lt;/code&gt;, &lt;code&gt;postgresql-Mon-01&lt;/code&gt;, etc. You should be able to see how combining these three &lt;code&gt;postgresql.conf&lt;/code&gt; parameters and some crafty strftime() escapes gives you a &lt;em&gt;ton&lt;/em&gt; of flexibility in your logging. So go forth and tweak those logs!&lt;/p&gt;
</description>
    <link>http://hunleyd.github.io/PostgreSQL-logging-strftime-and-you/ </link>
    <pubDate>2016-11-21T07:17:03-05:00</pubDate>
    <guid isPermaLink="true">http://hunleyd.github.io/PostgreSQL-logging-strftime-and-you/</guid>
   </item>
  
   <item>
    <title>Upgrading PostgreSQL 5x faster</title>
    <description>&lt;p&gt;&lt;img src=&quot;http://www.navops.io/img/launch-samsung-1.gif&quot; border=0 align=left style=&quot;PADDING-RIGHT: 5px&quot; height=100 width=100&gt;Upgrading your PostgreSQL database from one major version (e.g. 9.4.x) to another major version (e.g. 9.5.x) used to a painful and exceedingly slow process. You essentially had two options: dump / reload the data or use one of the complex logical replication tools.&lt;/p&gt;

&lt;p&gt;Thankfully, the PostgreSQL team introduced &lt;code&gt;pg_upgrade&lt;/code&gt; back in version 9.0. Because the way data is stored internally in its datafiles in PostgreSQL rarely changes, &lt;code&gt;pg_upgrade&lt;/code&gt; is able to re-use the existing datafiles (while manipulating some catalog entries) to &amp;quot;short circuit&amp;quot; the upgrade process. While this isn&amp;#39;t (yet) a true &amp;quot;in place upgrade&amp;quot; as done by some other databases, it&amp;#39;s pretty close. And it&amp;#39;s stupid fast. In my testing on my overworked Macbook Pro, it took &lt;em&gt;1/5&lt;/em&gt; as long to upgrade as a traditional dump and reload. So, let&amp;#39;s look at this process shall we?&lt;/p&gt;

&lt;p&gt;First, we assume that we have both PostgreSQL 9.5 and 9.6 installed and both have initialized (empty) clusters (see &lt;a href=&quot;https://hunleyd.github.io/Getting-fancy-with-PostgreSQL-and-Homebrew/&quot;&gt;here&lt;/a&gt; if you need to do this). We&amp;#39;re going to use &lt;code&gt;pgbench&lt;/code&gt; to create some data in our PostgreSQL 9.5 instance:&lt;/p&gt;
&lt;figure class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-text&quot; data-lang=&quot;text&quot;&gt;doug@Douglass-MacBook-Pro ~/foo ¬ª pg 9.5
doug@Douglass-MacBook-Pro ~/foo ¬ª createdb bench1; createdb bench2; createdb bench3
doug@Douglass-MacBook-Pro ~/foo ¬ª pgbench -i -s 15 bench1 ; pgbench -i -s 70 bench2 ; pgbench -i -s 600 bench3
doug@Douglass-MacBook-Pro ~/foo ¬ª pgbench -c 4 -j 2 -T 600 bench1 ; pgbench -c 4 -j 2 -T 600 bench2 ; pgbench -c 4 -j 2 -T 600 bench3
&lt;/code&gt;&lt;/pre&gt;&lt;/figure&gt;
&lt;p&gt;Now that we&amp;#39;ve got data in our cluster, we can do the dump. If this were a production instance, &lt;em&gt;this is where you&amp;#39;d have to stop your application(s)&lt;/em&gt;.&lt;/p&gt;
&lt;figure class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-text&quot; data-lang=&quot;text&quot;&gt;doug@Douglass-MacBook-Pro ~/foo ¬ª time pg_dumpall &amp;gt; data.sql
pg_dumpall &amp;gt; data.sql  20.57s user 30.63s system 4% cpu 18:43.70 total
&lt;/code&gt;&lt;/pre&gt;&lt;/figure&gt;
&lt;p&gt;We&amp;#39;ve now dumped out all our data, and spent 18 minutes with the application(s) down. Let&amp;#39;s restore our data to the PostgreSQL 9.6 cluster now:&lt;/p&gt;
&lt;figure class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-text&quot; data-lang=&quot;text&quot;&gt;doug@Douglass-MacBook-Pro ~/foo ¬ª pg 9.6
doug@Douglass-MacBook-Pro ~/foo ¬ª time psql -f data.sql
psql -f data.sql  14.53s user 18.30s system 1% cpu 37:48.49 total
&lt;/code&gt;&lt;/pre&gt;&lt;/figure&gt;
&lt;p&gt;After 37 minutes, our data is back and we can start our applications back up. &lt;em&gt;An outage of approximately 56.5 minutes&lt;/em&gt;.&lt;/p&gt;

&lt;p&gt;Now, let&amp;#39;s blow away our PostgreSQL 9.6 cluster and use &lt;code&gt;pg_upgrade&lt;/code&gt; to complete the same task. You would do this with the application(s) down as well!&lt;/p&gt;
&lt;figure class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-text&quot; data-lang=&quot;text&quot;&gt;doug@Douglass-MacBook-Pro ~/foo ¬ª rm -fr $PGDATA/*
doug@Douglass-MacBook-Pro ~/foo ¬ª initdb $PGDATA
doug@Douglass-MacBook-Pro ~/foo ¬ª export OPGDATA=$PGDATA/../9.5
doug@Douglass-MacBook-Pro ~/foo ¬ª time pg_upgrade -d $OPGDATA -D $PGDATA -b /usr/local/opt/postgresql-9.5/bin -B /usr/local/opt/postgresql-9.6/bin
pg_upgrade -d $OPGDATA -D $PGDATA -b /usr/local/opt/postgresql-9.5/bin -B   0.40s user 12.12s system 1% cpu 10:26.64 total
&lt;/code&gt;&lt;/pre&gt;&lt;/figure&gt;
&lt;p&gt;And we&amp;#39;re done &lt;em&gt;in 10.5 minutes&lt;/em&gt;. It took 1/5 the outage of the dump / load method. And that&amp;#39;s on my puny dataset with my overworked laptop! Pretty impressive, no?&lt;/p&gt;

&lt;p&gt;For the curious, the &lt;code&gt;pg_upgrade&lt;/code&gt; output that I omitted above for readability&amp;#39;s sake is:&lt;/p&gt;

&lt;p&gt;&lt;noscript&gt;&lt;pre&gt;```&lt;/p&gt;

&lt;h2&gt;Performing Consistency Checks&lt;/h2&gt;

&lt;p&gt;Checking cluster versions                                   ok
Checking database user is the install user                  ok
Checking database connection settings                       ok
Checking for prepared transactions                          ok
Checking for reg* system OID user data types                ok
Checking for contrib/isn with bigint-passing mismatch       ok
Checking for roles starting with &amp;#39;pg_&amp;#39;                      ok
Creating dump of global objects                             ok
Creating dump of database schemas
                                                            ok
Checking for presence of required libraries                 ok
Checking database user is the install user                  ok
Checking for prepared transactions                          ok&lt;/p&gt;

&lt;p&gt;If pg_upgrade fails after this point, you must re-initdb the
new cluster before continuing.&lt;/p&gt;

&lt;h2&gt;Performing Upgrade&lt;/h2&gt;

&lt;p&gt;Analyzing all rows in the new cluster                       ok
Freezing all rows on the new cluster                        ok
Deleting files from new pg&lt;em&gt;clog                             ok
Copying old pg&lt;/em&gt;clog to new server                           ok
Setting next transaction ID and epoch for new cluster       ok
Deleting files from new pg&lt;em&gt;multixact/offsets                ok
Copying old pg&lt;/em&gt;multixact/offsets to new server              ok
Deleting files from new pg&lt;em&gt;multixact/members                ok
Copying old pg&lt;/em&gt;multixact/members to new server              ok
Setting next multixact ID and offset for new cluster        ok
Resetting WAL archives                                      ok
Setting frozenxid and minmxid counters in new cluster       ok
Restoring global objects in the new cluster                 ok
Restoring database schemas in the new cluster
                                                            ok
Copying user relation files                                 ok
Setting next OID for new cluster                            ok
Sync data directory to disk                                 ok
Creating script to analyze new cluster                      ok
Creating script to delete old cluster                       ok&lt;/p&gt;

&lt;h2&gt;Upgrade Complete&lt;/h2&gt;

&lt;p&gt;Optimizer statistics are not transferred by pg&lt;em&gt;upgrade so,
once you start the new server, consider running:
    ./analyze&lt;/em&gt;new_cluster.sh&lt;/p&gt;

&lt;p&gt;Running this script will delete the old cluster&amp;#39;s data files:
    ./delete&lt;em&gt;old&lt;/em&gt;cluster.sh
```&lt;/pre&gt;&lt;/noscript&gt;&lt;script src=&quot;https://gist.github.com/hunleyd/3ff1f5503fc42e3446b35715bd0ec932.js&quot;&gt; &lt;/script&gt;&lt;/p&gt;
</description>
    <link>http://hunleyd.github.io/Upgrading-PostgreSQL-5x-faster/ </link>
    <pubDate>2016-11-18T07:18:28-05:00</pubDate>
    <guid isPermaLink="true">http://hunleyd.github.io/Upgrading-PostgreSQL-5x-faster/</guid>
   </item>
  
   <item>
    <title>Managing multiple PostgreSQL installs via Homebrew</title>
    <description>&lt;p&gt;&lt;img src=&quot;http://cdn.curvve.com/wp-content/uploads/2013/09/homebrew_osx_logo.png&quot; border=0 align=right style=&quot;PADDING-LEFT: 5px&quot;&gt;Following on from &lt;a href=&quot;https://hunleyd.github.io/Getting-fancy-with-PostgreSQL-and-Homebrew/&quot;&gt;this&lt;/a&gt; post, you probably have multiple versions of PostgreSQL installed on your Mac. In that post, I added an example function to help you manage all these concurrent installs. Today, I&amp;#39;m back with a full-fledged shell script to help manage all this. Without further ado, the script:&lt;/p&gt;

&lt;p&gt;&lt;noscript&gt;&lt;pre&gt;#!/bin/sh&lt;/p&gt;

&lt;p&gt;wanted&lt;em&gt;ver=$1
no&lt;/em&gt;restart=&lt;/p&gt;

&lt;h1&gt;is the version requested installed?&lt;/h1&gt;

&lt;p&gt;brew ls --version postgresql-${wanted&lt;em&gt;ver} &amp;amp;&amp;gt;/dev/null
if [[ $? -eq 0 ]] ; then
  # yes, carry on
  :
else
  # nope, so install it
  echo -n &amp;quot;Installing PostgreSQL ${wanted&lt;/em&gt;ver}... &amp;quot;
  brew install postgresql-${wanted_ver} &amp;amp;&amp;gt;/tmp/brew.out
  if [[ $? -eq 0 ]] ; then
    echo &amp;quot;done&amp;quot;
  else
    echo &amp;quot;FAILED!&amp;quot;
    cat /tmp/brew.out
    exit
fi&lt;/p&gt;

&lt;h1&gt;is postgresql is running?&lt;/h1&gt;

&lt;p&gt;for i in /usr/local/var/postgres/*
do
  check&lt;em&gt;ver=$(basename ${i})
  is&lt;/em&gt;running=$(ps -few | egrep -- &amp;quot;[p]ostgres.&lt;em&gt;-D.&lt;/em&gt;${check_ver}&amp;quot;)&lt;/p&gt;

&lt;p&gt;if [[ -z ${is&lt;em&gt;running} ]] ; then
    # nope, carry on
    :
  else
    # it is. is it the requested version?
    if [[ &amp;quot;${wanted&lt;/em&gt;ver}&amp;quot; = &amp;quot;${check&lt;em&gt;ver}&amp;quot; ]] ; then
      # yup, carry on
      no&lt;/em&gt;restart=t
    else
      # nope, so kill it
      echo -n &amp;quot;Stopping PostgreSQL ${check&lt;em&gt;ver}... &amp;quot;
      /usr/local/opt/postgresql-${check&lt;/em&gt;ver}/bin/pg&lt;em&gt;ctl -D /usr/local/var/postgres/${check&lt;/em&gt;ver} stop -w -mf &amp;amp;&amp;gt;/tmp/stop.out
      if [[ $? -eq 0 ]] ; then
        echo &amp;quot;done!&amp;quot;
      else
        echo &amp;quot;FAILED!&amp;quot;
        cat /tmp/stop.out
      fi
    fi
  fi
done&lt;/p&gt;

&lt;h1&gt;what version is active?&lt;/h1&gt;

&lt;p&gt;active_ver=$(/usr/bin/stat -f %Y /usr/local/bin/psql | cut -d\/ -f3 | cut -d- -f2)&lt;/p&gt;

&lt;h1&gt;is the active version the requested version?&lt;/h1&gt;

&lt;p&gt;if [[ &amp;quot;${active&lt;em&gt;ver}&amp;quot; = &amp;quot;${wanted&lt;/em&gt;ver}&amp;quot; ]] ; then
  # yup, carry on
  :
else
  # nope, so deactivate it
  echo -n &amp;quot;Deactivating PostgreSQL ${active&lt;em&gt;ver}... &amp;quot;
  brew unlink --force --overwrite postgresql-${active&lt;/em&gt;ver} &amp;amp;&amp;gt;/dev/null
  echo &amp;quot;done!&amp;quot;
  # and activate the correct version
  echo -n &amp;quot;Activating PostgreSQL ${wanted&lt;em&gt;ver}... &amp;quot;
  brew link --force --overwrite postgresql-${wanted&lt;/em&gt;ver} &amp;amp;&amp;gt;/dev/null
  echo &amp;quot;done!&amp;quot;
fi&lt;/p&gt;

&lt;h1&gt;point to the correct data dir&lt;/h1&gt;

&lt;p&gt;export PGDATA=/usr/local/var/postgres/${wanted_ver}&lt;/p&gt;

&lt;h1&gt;should we be starting a cluster?&lt;/h1&gt;

&lt;p&gt;if [[ &amp;quot;${no&lt;em&gt;restart}&amp;quot; = &amp;quot;t&amp;quot; ]] ; then
  # nope, carry on
  :
else
  # yup. has the cluster been initialized?
  if [[ ! -d ${PGDATA} ]] ; then
    # nope, so let&amp;#39;s do that
    echo -n &amp;quot;Initializing PostgreSQL ${wanted&lt;/em&gt;ver} cluster... &amp;quot;
    mkdir ${PGDATA}
    initdb -k ${PGDATA} &amp;amp;&amp;gt;/dev/null || initdb ${PGDATA} &amp;amp;&amp;gt;/dev/null
    echo &amp;quot;done!&amp;quot;
  else
    # yup, carry on
    :
  fi
  # start the cluster
  echo -n &amp;quot;Starting PostgreSQL ${wanted&lt;em&gt;ver}... &amp;quot;
  pg&lt;/em&gt;ctl -D ${PGDATA} start &amp;amp;&amp;gt;/tmp/postmaster.out
  if [[ $? -eq 0 ]] ; then
    echo &amp;quot;done!&amp;quot;
  else
    echo &amp;quot;FAILED!&amp;quot;
    cat /tmp/postmaster.out
  fi
  ret=1
  while [[ ${ret} -eq 1 ]]
  do
    # wait for the cluster to be available before exiting
    pg_isready -q
    ret=$?
  done
fi&lt;/pre&gt;&lt;/noscript&gt;&lt;script src=&quot;https://gist.github.com/hunleyd/0ee7d8745c2f9854b34ed48ae9196362.js&quot;&gt; &lt;/script&gt;&lt;/p&gt;

&lt;p&gt;But what does it do? It&amp;#39;s pretty simple actually. When you call this script, you tell it what version of PostgreSQL you want:&lt;/p&gt;
&lt;figure class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-text&quot; data-lang=&quot;text&quot;&gt;doug@Douglass-MacBook-Pro ~ ¬ª pg 9.6
&lt;/code&gt;&lt;/pre&gt;&lt;/figure&gt;
&lt;p&gt;and then the script does the following:&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;checks if the requested version is installed, and installs it if not&lt;/li&gt;
&lt;li&gt;checks if another version of PostgreSQL is running, and stops it&lt;/li&gt;
&lt;li&gt;checks if another version is linked as the active version, and unlinks it&lt;/li&gt;
&lt;li&gt;links the requested version as the active version&lt;/li&gt;
&lt;li&gt;sets PGDATA to point to the requested version&amp;#39;s data cluster&lt;/li&gt;
&lt;li&gt;does an &lt;code&gt;initdb&lt;/code&gt; for the requested version if needed&lt;/li&gt;
&lt;li&gt;starts the requested version&amp;#39;s cluster&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;I&amp;#39;ll be the first to admit that the script could use additional work, but it&amp;#39;s functional enough to start using today. As I continue to improve the script, I&amp;#39;ll update the gist with those changes, so check back every so often.&lt;/p&gt;

&lt;p&gt;Enjoy.&lt;/p&gt;
</description>
    <link>http://hunleyd.github.io/Managing-multiple-PostgreSQL-installs-via-Homebrew/ </link>
    <pubDate>2016-11-16T08:45:27-05:00</pubDate>
    <guid isPermaLink="true">http://hunleyd.github.io/Managing-multiple-PostgreSQL-installs-via-Homebrew/</guid>
   </item>
  
   <item>
    <title>Getting fancy with PostgreSQL and Homebrew</title>
    <description>&lt;p&gt;&lt;img src=&quot;http://cdn.curvve.com/wp-content/uploads/2013/09/homebrew_osx_logo.png&quot; border=0 align=right style=&quot;PADDING-LEFT: 5px&quot;&gt;In our &lt;a href=&quot;https://hunleyd.github.io/PostgreSQL-Homebrew-and-You/&quot;&gt;previous&lt;/a&gt; post, we installed PostgreSQL via Homebrew and got our own little cluster up and running under our userid. That is probably good enough for 90% of the users out there who just want to play with or devel on PostgreSQL, but for those of us who need a little more flexibility in our installs, we&amp;#39;re going to take the next step.&lt;/p&gt;

&lt;p&gt;First, if you have any data in your existing cluster that you want to preserve, let&amp;#39;s backup it up. We&amp;#39;re just going to use &lt;code&gt;pg_dumpall&lt;/code&gt; here since it&amp;#39;s quick-n-dirty:&lt;/p&gt;

&lt;p&gt;&lt;noscript&gt;&lt;pre&gt;&lt;code&gt;bash
doug@Douglass-MacBook-Pro ~ ¬ª
doug@Douglass-MacBook-Pro ~ ¬ª pg_dumpall -g &amp;amp;gt; my_roles.sql
doug@Douglass-MacBook-Pro ~ ¬ª pg_dumpall &amp;amp;gt; my_data.sql
doug@Douglass-MacBook-Pro ~ ¬ª
&lt;/code&gt;&lt;/pre&gt;&lt;/noscript&gt;&lt;script src=&quot;https://gist.github.com/hunleyd/22e765b45c877b5c9c2e35722b464393.js&quot;&gt; &lt;/script&gt;&lt;/p&gt;

&lt;p&gt;Now, we can stop our cluster:&lt;/p&gt;

&lt;p&gt;&lt;noscript&gt;&lt;pre&gt;&lt;code&gt;bash
doug@Douglass-MacBook-Pro ~ ¬ª
doug@Douglass-MacBook-Pro ~ ¬ª brew services stop postgresql
Stopping `postgresql`... (might take a while)
==&amp;amp;gt; Successfully stopped `postgresql` (label: homebrew.mxcl.postgresql)
doug@Douglass-MacBook-Pro ~ ¬ª
&lt;/code&gt;&lt;/pre&gt;&lt;/noscript&gt;&lt;script src=&quot;https://gist.github.com/hunleyd/f02a36a115c3fed3310e7abc5f3fb419.js&quot;&gt; &lt;/script&gt;&lt;/p&gt;

&lt;p&gt;And uninstall the current PostgreSQL:&lt;/p&gt;

&lt;p&gt;&lt;noscript&gt;&lt;pre&gt;&lt;code&gt;bash
doug@Douglass-MacBook-Pro ~ ¬ª
doug@Douglass-MacBook-Pro ~ ¬ª brew uninstall postgresql
Uninstalling /usr/local/Cellar/postgresql/9.5.5... (3,154 files, 35.1M)
doug@Douglass-MacBook-Pro ~ ¬ª
&lt;/code&gt;&lt;/pre&gt;&lt;/noscript&gt;&lt;script src=&quot;https://gist.github.com/hunleyd/4dffee8e9ebbf2c052162f2ecc36e812.js&quot;&gt; &lt;/script&gt;&lt;/p&gt;

&lt;p&gt;And remove the remnants of our cluster:&lt;/p&gt;

&lt;p&gt;&lt;noscript&gt;&lt;pre&gt;&lt;code&gt;bash
doug@Douglass-MacBook-Pro ~ ¬ª
doug@Douglass-MacBook-Pro ~ ¬ª rm -rf /usr/local/var/postgres
doug@Douglass-MacBook-Pro ~ ¬ª
&lt;/code&gt;
&lt;/pre&gt;&lt;/noscript&gt;&lt;script src=&quot;https://gist.github.com/hunleyd/7c064e25c8916fa7fe0e3cdb846d3c78.js&quot;&gt; &lt;/script&gt;&lt;/p&gt;

&lt;p&gt;Now we&amp;#39;ve got a clean slate. So, let&amp;#39;s tell Homebrew to stop using the default PostgreSQL and use Peter Eisentraut&amp;#39;s version (if you don&amp;#39;t know, Peter actually contributes to PostgreSQL):&lt;/p&gt;

&lt;p&gt;&lt;noscript&gt;&lt;pre&gt;```bash
doug@Douglass-MacBook-Pro ~ ¬ª 
doug@Douglass-MacBook-Pro ~ ¬ª brew tap petere/postgresql
Updating Homebrew...
==&amp;gt; Auto-updated Homebrew!
Updated 1 tap (homebrew/core).
==&amp;gt; New Formulae
[snip]
==&amp;gt; Updated Formulae
[snip]
==&amp;gt; Deleted Formulae
[snip]&lt;/p&gt;

&lt;p&gt;==&amp;gt; Tapping petere/postgresql
Cloning into &amp;#39;/usr/local/Homebrew/Library/Taps/petere/homebrew-postgresql&amp;#39;...
remote: Counting objects: 15, done.
remote: Compressing objects: 100% (11/11), done.
remote: Total 15 (delta 9), reused 5 (delta 4), pack-reused 0
Unpacking objects: 100% (15/15), done.
Checking connectivity... done.
Tapped 11 formulae (49 files, 71.7K)
doug@Douglass-MacBook-Pro ~ ¬ª 
```&lt;/pre&gt;&lt;/noscript&gt;&lt;script src=&quot;https://gist.github.com/hunleyd/b099ff10c1cd1713f37ff40cf320adf3.js&quot;&gt; &lt;/script&gt;&lt;/p&gt;

&lt;p&gt;As of this writing, Peter makes PostgreSQL 8.3 and above available. However, only PostgreSQL 9.2 and above are officially supported by the PostgreSQL community. So let&amp;#39;s install the supported versions:&lt;/p&gt;

&lt;p&gt;&lt;noscript&gt;&lt;pre&gt;```bash
doug@Douglass-MacBook-Pro ~ ¬ª
doug@Douglass-MacBook-Pro ~ ¬ª for i in $(seq 2 6)
\ do
\ brew install postgresql-9.${i}
\ done
==&amp;gt; Installing postgresql-9.2 from petere/postgresql
==&amp;gt; Tapping homebrew/dupes
Cloning into &amp;#39;/usr/local/Homebrew/Library/Taps/homebrew/homebrew-dupes&amp;#39;...
remote: Counting objects: 42, done.
remote: Compressing objects: 100% (42/42), done.
remote: Total 42 (delta 0), reused 4 (delta 0), pack-reused 0
Unpacking objects: 100% (42/42), done.
Checking connectivity... done.
Tapped 38 formulae (103 files, 121.4K)
==&amp;gt; Installing dependencies for petere/postgresql/postgresql-9.2: gettext, homebrew/dupes/openldap, ossp-uuid, homebrew/dupes/tcl-tk
==&amp;gt; Installing petere/postgresql/postgresql-9.2 dependency: get
==&amp;gt; Downloading https://homebrew.bintray.com/bottles/gettext-0.19.8.1.sierra.bot&lt;/p&gt;

&lt;h6&gt;################################################################## 100.0%&lt;/h6&gt;

&lt;p&gt;==&amp;gt; Pouring gettext-0.19.8.1.sierra.bottle.tar.gz
==&amp;gt; Caveats
This formula is keg-only, which means it was not symlinked into /usr/local.&lt;/p&gt;

&lt;p&gt;macOS provides the BSD gettext library and some software gets confused if both are in the library path.&lt;/p&gt;

&lt;p&gt;Generally there are no consequences of this for you. If you build your
own software and it requires this formula, you will need to add to your
build variables:&lt;/p&gt;
&lt;figure class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-text&quot; data-lang=&quot;text&quot;&gt;LDFLAGS:  -L/usr/local/opt/gettext/lib
CPPFLAGS: -I/usr/local/opt/gettext/include
&lt;/code&gt;&lt;/pre&gt;&lt;/figure&gt;
&lt;p&gt;==&amp;gt; Summary
üç∫   /usr/local/Cellar/gettext/0.19.8.1: 1,934 files, 16.9M
==&amp;gt; Installing petere/postgresql/postgresql-9.2 dependency: homebrew/dupes/
==&amp;gt; Downloading https://homebrew.bintray.com/bottles-dupes/openldap-2.4.44.sierr&lt;/p&gt;

&lt;h6&gt;################################################################## 100.0%&lt;/h6&gt;

&lt;p&gt;==&amp;gt; Pouring openldap-2.4.44.sierra.bottle.tar.gz
==&amp;gt; Caveats
This formula is keg-only, which means it was not symlinked into /usr/local.&lt;/p&gt;

&lt;p&gt;macOS already provides this software and installing another version in
parallel can cause all kinds of trouble.&lt;/p&gt;

&lt;p&gt;Generally there are no consequences of this for you. If you build your
own software and it requires this formula, you will need to add to your
build variables:&lt;/p&gt;
&lt;figure class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-text&quot; data-lang=&quot;text&quot;&gt;LDFLAGS:  -L/usr/local/opt/openldap/lib
CPPFLAGS: -I/usr/local/opt/openldap/include
&lt;/code&gt;&lt;/pre&gt;&lt;/figure&gt;
&lt;p&gt;==&amp;gt; Summary
üç∫   /usr/local/Cellar/openldap/2.4.44: 295 files, 6.3M
==&amp;gt; Installing petere/postgresql/postgresql-9.2 dependency: ossp-uuid
==&amp;gt; Downloading https://homebrew.bintray.com/bottles/ossp-uuid-1.6.2_2.sierra.bo&lt;/p&gt;

&lt;h6&gt;################################################################## 100.0%&lt;/h6&gt;

&lt;p&gt;==&amp;gt; Pouring ossp-uuid-1.6.2&lt;em&gt;2.sierra.bottle.tar.gz
üç∫   /usr/local/Cellar/ossp-uuid/1.6.2&lt;/em&gt;2: 17 files, 206K
==&amp;gt; Installing petere/postgresql/postgresql-9.2 dependency: homebrew/dupes/
==&amp;gt; Using the sandbox
==&amp;gt; Downloading https://downloads.sourceforge.net/project/tcl/Tcl/8.6.6/tcl8.6.6
==&amp;gt; Downloading from http://iweb.dl.sourceforge.net/project/tcl/Tcl/8.6.6/tcl8.6&lt;/p&gt;

&lt;h6&gt;################################################################## 100.0%&lt;/h6&gt;

&lt;p&gt;==&amp;gt; ./configure --prefix=/usr/local/Cellar/tcl-tk/8.6.6 --mandir=/usr/local/Cell
==&amp;gt; make
==&amp;gt; make install
==&amp;gt; make install-private-headers
==&amp;gt; Downloading https://downloads.sourceforge.net/project/tcl/Tcl/8.6.6/tk8.6.6-
==&amp;gt; Downloading from http://heanet.dl.sourceforge.net/project/tcl/Tcl/8.6.6/tk8.&lt;/p&gt;

&lt;h6&gt;################################################################## 100.0%&lt;/h6&gt;

&lt;p&gt;==&amp;gt; ./configure --prefix=/usr/local/Cellar/tcl-tk/8.6.6 --mandir=/usr/local/Cell
==&amp;gt; make TK&lt;em&gt;LIBRARY=/usr/local/Cellar/tcl-tk/8.6.6/lib
==&amp;gt; make install
==&amp;gt; make install-private-headers
==&amp;gt; Downloading https://github.com/tcltk/tcllib/archive/tcllib&lt;/em&gt;1&lt;em&gt;18.tar.gz
==&amp;gt; Downloading from https://codeload.github.com/tcltk/tcllib/tar.gz/tcllib&lt;/em&gt;1_18&lt;/p&gt;

&lt;h6&gt;################################################################## 100.0%&lt;/h6&gt;

&lt;p&gt;==&amp;gt; ./configure --prefix=/usr/local/Cellar/tcl-tk/8.6.6 --mandir=/usr/local/Cell
==&amp;gt; make install
==&amp;gt; Caveats
This formula is keg-only, which means it was not symlinked into /usr/local.&lt;/p&gt;

&lt;p&gt;Tk installs some X11 headers and OS X provides an (older) Tcl/Tk.&lt;/p&gt;

&lt;p&gt;Generally there are no consequences of this for you. If you build your
own software and it requires this formula, you will need to add to your
build variables:&lt;/p&gt;
&lt;figure class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-text&quot; data-lang=&quot;text&quot;&gt;LDFLAGS:  -L/usr/local/opt/tcl-tk/lib
CPPFLAGS: -I/usr/local/opt/tcl-tk/include
PKG_CONFIG_PATH: /usr/local/opt/tcl-tk/lib/pkgconfig
&lt;/code&gt;&lt;/pre&gt;&lt;/figure&gt;
&lt;p&gt;==&amp;gt; Summary
üç∫   /usr/local/Cellar/tcl-tk/8.6.6: 2,847 files, 29.2M, built in 5 minutes 31 seconds
==&amp;gt; Installing petere/postgresql/postgresql-9.2
==&amp;gt; Downloading https://ftp.postgresql.org/pub/source/v9.2.19/postgresql-9.2.19.&lt;/p&gt;

&lt;h6&gt;################################################################## 100.0%&lt;/h6&gt;

&lt;p&gt;==&amp;gt; Patching
patching file contrib/uuid-ossp/uuid-ossp.c
==&amp;gt; ./configure --prefix=/usr/local/Cellar/postgresql-9.2/9.2.19 --enable-dtrace
==&amp;gt; make install-world
==&amp;gt; Caveats
To use this PostgreSQL installation, do one or more of the following:&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;Call all programs explicitly with /usr/local/opt/postgresql-9.2/bin/...&lt;/li&gt;
&lt;li&gt;Add /usr/local/opt/postgresql-9.2/bin to your PATH&lt;/li&gt;
&lt;li&gt;brew link -f postgresql-9.2&lt;/li&gt;
&lt;li&gt;Install the postgresql-common package&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;To access the man pages, do one or more of the following:
- Refer to them by their full path, like &lt;code&gt;man /usr/local/opt/postgresql-9.2/share/man/man1/psql.1&lt;/code&gt;
- Add /usr/local/opt/postgresql-9.2/share/man to your MANPATH
- brew link -f postgresql-9.2&lt;/p&gt;

&lt;p&gt;This formula is keg-only, which means it was not symlinked into /usr/local.&lt;/p&gt;

&lt;p&gt;The different provided versions of PostgreSQL conflict with each other.&lt;/p&gt;

&lt;p&gt;Generally there are no consequences of this for you. If you build your
own software and it requires this formula, you will need to add to your
build variables:&lt;/p&gt;
&lt;figure class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-text&quot; data-lang=&quot;text&quot;&gt;LDFLAGS:  -L/usr/local/opt/postgresql-9.2/lib
CPPFLAGS: -I/usr/local/opt/postgresql-9.2/include
&lt;/code&gt;&lt;/pre&gt;&lt;/figure&gt;
&lt;p&gt;==&amp;gt; Summary
üç∫   /usr/local/Cellar/postgresql-9.2/9.2.19: 3,120 files, 40M, built in 3 minutes 28 seconds
Updating Homebrew...
==&amp;gt; Auto-updated Homebrew!
Updated 1 tap (homebrew/core).
==&amp;gt; Updated Formulae
[snip]&lt;/p&gt;

&lt;p&gt;==&amp;gt; Installing postgresql-9.3 from petere/postgresql
==&amp;gt; Downloading https://ftp.postgresql.org/pub/source/v9.3.15/postgresql-9.3.15.&lt;/p&gt;

&lt;h6&gt;################################################################## 100.0%&lt;/h6&gt;

&lt;p&gt;==&amp;gt; Patching
patching file contrib/uuid-ossp/uuid-ossp.c
==&amp;gt; ./configure --prefix=/usr/local/Cellar/postgresql-9.3/9.3.15 --enable-dtrace
==&amp;gt; make install-world
==&amp;gt; Caveats
To use this PostgreSQL installation, do one or more of the following:&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;Call all programs explicitly with /usr/local/opt/postgresql-9.3/bin/...&lt;/li&gt;
&lt;li&gt;Add /usr/local/opt/postgresql-9.3/bin to your PATH&lt;/li&gt;
&lt;li&gt;brew link -f postgresql-9.3&lt;/li&gt;
&lt;li&gt;Install the postgresql-common package&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;To access the man pages, do one or more of the following:
- Refer to them by their full path, like &lt;code&gt;man /usr/local/opt/postgresql-9.3/share/man/man1/psql.1&lt;/code&gt;
- Add /usr/local/opt/postgresql-9.3/share/man to your MANPATH
- brew link -f postgresql-9.3&lt;/p&gt;

&lt;p&gt;This formula is keg-only, which means it was not symlinked into /usr/local.&lt;/p&gt;

&lt;p&gt;The different provided versions of PostgreSQL conflict with each other.&lt;/p&gt;

&lt;p&gt;Generally there are no consequences of this for you. If you build your
own software and it requires this formula, you will need to add to your
build variables:&lt;/p&gt;
&lt;figure class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-text&quot; data-lang=&quot;text&quot;&gt;LDFLAGS:  -L/usr/local/opt/postgresql-9.3/lib
CPPFLAGS: -I/usr/local/opt/postgresql-9.3/include
PKG_CONFIG_PATH: /usr/local/opt/postgresql-9.3/lib/pkgconfig
&lt;/code&gt;&lt;/pre&gt;&lt;/figure&gt;
&lt;p&gt;==&amp;gt; Summary
üç∫   /usr/local/Cellar/postgresql-9.3/9.3.15: 3,190 files, 41M, built in 3 minutes 17 seconds
==&amp;gt; Installing postgresql-9.4 from petere/postgresql
==&amp;gt; Installing dependencies for petere/postgresql/postgresql-9.4: e2fsprogs
==&amp;gt; Installing petere/postgresql/postgresql-9.4 dependency: e2fsprogs
==&amp;gt; Downloading https://homebrew.bintray.com/bottles/e2fsprogs-1.42.13.sierra.bo&lt;/p&gt;

&lt;h6&gt;################################################################## 100.0%&lt;/h6&gt;

&lt;p&gt;==&amp;gt; Pouring e2fsprogs-1.42.13.sierra.bottle.tar.gz
==&amp;gt; Caveats
This formula is keg-only, which means it was not symlinked into /usr/local.&lt;/p&gt;

&lt;p&gt;This brew installs several commands which override macOS-provided file system commands.&lt;/p&gt;

&lt;p&gt;Generally there are no consequences of this for you. If you build your
own software and it requires this formula, you will need to add to your
build variables:&lt;/p&gt;
&lt;figure class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-text&quot; data-lang=&quot;text&quot;&gt;LDFLAGS:  -L/usr/local/opt/e2fsprogs/lib
CPPFLAGS: -I/usr/local/opt/e2fsprogs/include
PKG_CONFIG_PATH: /usr/local/opt/e2fsprogs/lib/pkgconfig
&lt;/code&gt;&lt;/pre&gt;&lt;/figure&gt;
&lt;p&gt;==&amp;gt; Summary
üç∫   /usr/local/Cellar/e2fsprogs/1.42.13: 135 files, 5.0M
==&amp;gt; Installing petere/postgresql/postgresql-9.4
==&amp;gt; Downloading https://ftp.postgresql.org/pub/source/v9.4.10/postgresql-9.4.10.&lt;/p&gt;

&lt;h6&gt;################################################################## 100.0%&lt;/h6&gt;

&lt;p&gt;==&amp;gt; ./configure --prefix=/usr/local/Cellar/postgresql-9.4/9.4.10 --enable-dtrace
==&amp;gt; make install-world
==&amp;gt; Caveats
To use this PostgreSQL installation, do one or more of the following:&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;Call all programs explicitly with /usr/local/opt/postgresql-9.4/bin/...&lt;/li&gt;
&lt;li&gt;Add /usr/local/opt/postgresql-9.4/bin to your PATH&lt;/li&gt;
&lt;li&gt;brew link -f postgresql-9.4&lt;/li&gt;
&lt;li&gt;Install the postgresql-common package&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;To access the man pages, do one or more of the following:
- Refer to them by their full path, like &lt;code&gt;man /usr/local/opt/postgresql-9.4/share/man/man1/psql.1&lt;/code&gt;
- Add /usr/local/opt/postgresql-9.4/share/man to your MANPATH
- brew link -f postgresql-9.4&lt;/p&gt;

&lt;p&gt;This formula is keg-only, which means it was not symlinked into /usr/local.&lt;/p&gt;

&lt;p&gt;The different provided versions of PostgreSQL conflict with each other.&lt;/p&gt;

&lt;p&gt;Generally there are no consequences of this for you. If you build your
own software and it requires this formula, you will need to add to your
build variables:&lt;/p&gt;
&lt;figure class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-text&quot; data-lang=&quot;text&quot;&gt;LDFLAGS:  -L/usr/local/opt/postgresql-9.4/lib
CPPFLAGS: -I/usr/local/opt/postgresql-9.4/include
PKG_CONFIG_PATH: /usr/local/opt/postgresql-9.4/lib/pkgconfig
&lt;/code&gt;&lt;/pre&gt;&lt;/figure&gt;
&lt;p&gt;==&amp;gt; Summary
üç∫   /usr/local/Cellar/postgresql-9.4/9.4.10: 3,261 files, 42.9M, built in 3 minutes 17 seconds
==&amp;gt; Installing postgresql-9.5 from petere/postgresql
==&amp;gt; Downloading https://ftp.postgresql.org/pub/source/v9.5.5/postgresql-9.5.5.ta&lt;/p&gt;

&lt;h6&gt;################################################################## 100.0%&lt;/h6&gt;

&lt;p&gt;==&amp;gt; ./configure --prefix=/usr/local/Cellar/postgresql-9.5/9.5.5 --enable-dtrace
==&amp;gt; make install-world
==&amp;gt; Caveats
To use this PostgreSQL installation, do one or more of the following:&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;Call all programs explicitly with /usr/local/opt/postgresql-9.5/bin/...&lt;/li&gt;
&lt;li&gt;Add /usr/local/opt/postgresql-9.5/bin to your PATH&lt;/li&gt;
&lt;li&gt;brew link -f postgresql-9.5&lt;/li&gt;
&lt;li&gt;Install the postgresql-common package&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;To access the man pages, do one or more of the following:
- Refer to them by their full path, like &lt;code&gt;man /usr/local/opt/postgresql-9.5/share/man/man1/psql.1&lt;/code&gt;
- Add /usr/local/opt/postgresql-9.5/share/man to your MANPATH
- brew link -f postgresql-9.5&lt;/p&gt;

&lt;p&gt;This formula is keg-only, which means it was not symlinked into /usr/local.&lt;/p&gt;

&lt;p&gt;The different provided versions of PostgreSQL conflict with each other.&lt;/p&gt;

&lt;p&gt;Generally there are no consequences of this for you. If you build your
own software and it requires this formula, you will need to add to your
build variables:&lt;/p&gt;
&lt;figure class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-text&quot; data-lang=&quot;text&quot;&gt;LDFLAGS:  -L/usr/local/opt/postgresql-9.5/lib
CPPFLAGS: -I/usr/local/opt/postgresql-9.5/include
PKG_CONFIG_PATH: /usr/local/opt/postgresql-9.5/lib/pkgconfig
&lt;/code&gt;&lt;/pre&gt;&lt;/figure&gt;
&lt;p&gt;==&amp;gt; Summary
üç∫   /usr/local/Cellar/postgresql-9.5/9.5.5: 3,395 files, 45M, built in 3 minutes 30 seconds
==&amp;gt; Installing postgresql-9.6 from petere/postgresql
==&amp;gt; Downloading https://ftp.postgresql.org/pub/source/v9.6.1/postgresql-9.6.1.ta&lt;/p&gt;

&lt;h6&gt;################################################################## 100.0%&lt;/h6&gt;

&lt;p&gt;==&amp;gt; ./configure --prefix=/usr/local/Cellar/postgresql-9.6/9.6.1 --enable-dtrace
==&amp;gt; make install-world
==&amp;gt; Caveats
To use this PostgreSQL installation, do one or more of the following:&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;Call all programs explicitly with /usr/local/opt/postgresql-9.6/bin/...&lt;/li&gt;
&lt;li&gt;Add /usr/local/opt/postgresql-9.6/bin to your PATH&lt;/li&gt;
&lt;li&gt;brew link -f postgresql-9.6&lt;/li&gt;
&lt;li&gt;Install the postgresql-common package&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;To access the man pages, do one or more of the following:
- Refer to them by their full path, like &lt;code&gt;man /usr/local/opt/postgresql-9.6/share/man/man1/psql.1&lt;/code&gt;
- Add /usr/local/opt/postgresql-9.6/share/man to your MANPATH
- brew link -f postgresql-9.6&lt;/p&gt;

&lt;p&gt;This formula is keg-only, which means it was not symlinked into /usr/local.&lt;/p&gt;

&lt;p&gt;The different provided versions of PostgreSQL conflict with each other.&lt;/p&gt;

&lt;p&gt;Generally there are no consequences of this for you. If you build your
own software and it requires this formula, you will need to add to your
build variables:&lt;/p&gt;
&lt;figure class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-text&quot; data-lang=&quot;text&quot;&gt;LDFLAGS:  -L/usr/local/opt/postgresql-9.6/lib
CPPFLAGS: -I/usr/local/opt/postgresql-9.6/include
PKG_CONFIG_PATH: /usr/local/opt/postgresql-9.6/lib/pkgconfig
&lt;/code&gt;&lt;/pre&gt;&lt;/figure&gt;
&lt;p&gt;==&amp;gt; Summary
üç∫   /usr/local/Cellar/postgresql-9.6/9.6.1: 3,485 files, 46.6M, built in 3 minutes 38 seconds
doug@Douglass-MacBook-Pro ~ ¬ª
```&lt;/pre&gt;&lt;/noscript&gt;&lt;script src=&quot;https://gist.github.com/hunleyd/bcc4e0e7c55e849b7adb647d9727674c.js&quot;&gt; &lt;/script&gt;&lt;/p&gt;

&lt;p&gt;As it says in the output, these are &amp;#39;keg-only&amp;#39;, which has the nice side effect that they are automatically installed in side-by-side directories &lt;code&gt;/usr/local/opt/postgresql-9.1/&lt;/code&gt; etc.&lt;/p&gt;

&lt;p&gt;Peter configures PostgreSQL with just about all the options turned on:&lt;/p&gt;

&lt;p&gt;&lt;noscript&gt;&lt;pre&gt;```bash
doug@Douglass-MacBook-Pro ~ ¬ª
oug@Douglass-MacBook-Pro ~ ¬ª pg_config |grep ^CONF
CONFIGURE = &amp;#39;--prefix=/usr/local/Cellar/postgresql-9.6/9.6.1&amp;#39; &amp;#39;--enable-dtrace&amp;#39; &amp;#39;--enable-nls&amp;#39; &amp;#39;--with-bonjour&amp;#39; &amp;#39;--with-gssapi&amp;#39; &amp;#39;--with-ldap&amp;#39; &amp;#39;--with-libxml&amp;#39; &amp;#39;--with-libxslt&amp;#39; &amp;#39;--with-openssl&amp;#39; &amp;#39;--with-uuid=e2fs&amp;#39; &amp;#39;--with-pam&amp;#39; &amp;#39;--with-perl&amp;#39; &amp;#39;--with-python&amp;#39; &amp;#39;--with-tcl&amp;#39; &amp;#39;--with-includes=/usr/local/opt/gettext/include:/usr/local/opt/openldap/include:/usr/local/opt/openssl/include:/usr/local/opt/readline/include:/usr/local/opt/tcl-tk/include&amp;#39; &amp;#39;--with-libraries=/usr/local/opt/gettext/lib:/usr/local/opt/openldap/lib:/usr/local/opt/openssl/lib:/usr/local/opt/readline/lib:/usr/local/opt/tcl-tk/lib&amp;#39; &amp;#39;CC=clang&amp;#39;
doug@Douglass-MacBook-Pro ~ ¬ª&lt;/pre&gt;&lt;/noscript&gt;&lt;script src=&quot;https://gist.github.com/hunleyd/c56727a3249042841c2609439209c8fd.js&quot;&gt; &lt;/script&gt;&lt;/p&gt;

&lt;p&gt;and you get all the extensions that are in &amp;#39;contrib&amp;#39; as well. However, if you find that you need to install another extension, I advocate using &lt;code&gt;pex&lt;/code&gt;. You would install it like this:&lt;/p&gt;

&lt;p&gt;&lt;noscript&gt;&lt;pre&gt;```bash
doug@Douglass-MacBook-Pro ~ ¬ª brew install pex
==&amp;gt; Installing dependencies for pex: postgresql
==&amp;gt; Installing pex dependency: postgresql
==&amp;gt; Downloading https://homebrew.bintray.com/bottles/postgresql-9.5.5.sierra.bot
Already downloaded: /Users/doug/Library/Caches/Homebrew/postgresql-9.5.5.sierra.bottle.tar.gz
==&amp;gt; Pouring postgresql-9.5.5.sierra.bottle.tar.gz
==&amp;gt; Using the sandbox
==&amp;gt; /usr/local/Cellar/postgresql/9.5.5/bin/initdb /usr/local/var/postgres
==&amp;gt; Caveats
If builds of PostgreSQL 9 are failing and you have version 8.x installed,
you may need to remove the previous version first. See:
  https://github.com/Homebrew/homebrew/issues/2510&lt;/p&gt;

&lt;p&gt;To migrate existing data from a previous major version (pre-9.0) of PostgreSQL, see:
  https://www.postgresql.org/docs/9.5/static/upgrading.html&lt;/p&gt;

&lt;p&gt;To migrate existing data from a previous minor version (9.0-9.4) of PostgreSQL, see:
  https://www.postgresql.org/docs/9.5/static/pgupgrade.html&lt;/p&gt;

&lt;p&gt;You will need your previous PostgreSQL installation from brew to perform &lt;code&gt;pg_upgrade&lt;/code&gt;.
   Do not run &lt;code&gt;brew cleanup postgresql&lt;/code&gt; until you have performed the migration.                                                                  1
To have launchd start postgresql now and restart at login:
  brew services start postgresql
Or, if you do not want/need a background service you can just run:
  pg_ctl -D /usr/local/var/postgres start
==&amp;gt; Summary
üç∫   /usr/local/Cellar/postgresql/9.5.5: 3,154 files, 35.1M
==&amp;gt; Installing pex
==&amp;gt; Downloading https://homebrew.bintray.com/bottles/pex-1.20140409.sierra.bottl&lt;/p&gt;

&lt;h6&gt;################################################################## 100.0%&lt;/h6&gt;

&lt;p&gt;==&amp;gt; Pouring pex-1.20140409.sierra.bottle.tar.gz
==&amp;gt; Caveats
If installing for the first time, perform the following in order to setup the necessary directory structure:
  pex init
==&amp;gt; Summary
üç∫   /usr/local/Cellar/pex/1.20140409: 5 files, 31.6K
doug@Douglass-MacBook-Pro ~ ¬ª
doug@Douglass-MacBook-Pro ~ ¬ª pex init
doug@Douglass-MacBook-Pro ~ ¬ª
```&lt;/pre&gt;&lt;/noscript&gt;&lt;script src=&quot;https://gist.github.com/hunleyd/37c2e01a0d400c0a16c7fb7d9b8d1030.js&quot;&gt; &lt;/script&gt;&lt;/p&gt;

&lt;p&gt;Sadly, it will reinstall the default PostgreSQL brew recipe, but we&amp;#39;ll simply pretend that it&amp;#39;s not there going forward. Once installed, use &lt;code&gt;pex&lt;/code&gt; like so:&lt;/p&gt;

&lt;p&gt;&lt;noscript&gt;&lt;pre&gt;```bash
doug@Douglass-MacBook-Pro ~ ¬ª pex -g /usr/local/opt/postgresql-9.4 install ip4r
==&amp;gt; Downloading ip4r from https://github.com/RhodiumToad/ip4r/archive/2.0.3.tar.gz&lt;/p&gt;

&lt;h6&gt;################################################################## 100.0%&lt;/h6&gt;

&lt;p&gt;==&amp;gt; Unpacking ip4r
[snip]
==&amp;gt; Building ip4r
[snip]
==&amp;gt; Installing ip4r
[snip]
/usr/bin/install -c -m 755  ip4r.so &amp;#39;/usr/local/Cellar/postgresql-9.4/9.4.10/lib/ip4r.so&amp;#39;
/usr/bin/install -c -m 644 ip4r.control &amp;#39;/usr/local/Cellar/postgresql-9.4/9.4.10/share/extension/&amp;#39;
/usr/bin/install -c -m 644 ip4r--2.0.sql ip4r--unpackaged2.0--2.0.sql ip4r--unpackaged1--2.0.sql                                                  ‚Ü™\  &amp;#39;/usr/local/Cellar/postgresql-9.4/9.4.10/share/extension/&amp;#39;
[snip]
==&amp;gt; Package ip4r installed successfully
doug@Douglass-MacBook-Pro ~ ¬ª
```&lt;/pre&gt;&lt;/noscript&gt;&lt;script src=&quot;https://gist.github.com/hunleyd/d2d004871557adc49ae77b19181bd999.js&quot;&gt; &lt;/script&gt;&lt;/p&gt;

&lt;p&gt;As you can see, the &lt;code&gt;ip4r&lt;/code&gt; extension was installed into my PostgreSQL 9.4 instance.&lt;/p&gt;

&lt;p&gt;Now, you might be wondering how to deal with all these concurrent versions. If you type &lt;code&gt;pg_dump&lt;/code&gt; which one willl you get? How can you force it to use a specific version? Right now, you won&amp;#39;t get any version, since it&amp;#39;s not in your path. You will need to specify exactly what you want:&lt;/p&gt;
&lt;figure class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-bash&quot; data-lang=&quot;bash&quot;&gt;doug@Douglass-MacBook-Pro ~ ¬ª /usr/local/opt/postgresql-9.6/bin/psql --version
psql (PostgreSQL) 9.6.1
doug@Douglass-MacBook-Pro ~ ¬ª
&lt;/code&gt;&lt;/pre&gt;&lt;/figure&gt;
&lt;p&gt;which is a huge pita. So, let&amp;#39;s make a little convenience function in our shell. Edit your &lt;code&gt;.zshrc&lt;/code&gt; or your &lt;code&gt;.bashrc&lt;/code&gt; (or whatever) and add a function like this:&lt;/p&gt;

&lt;p&gt;&lt;noscript&gt;&lt;pre&gt;```bash
    function pg()
    {
      ver=$1&lt;/p&gt;
&lt;figure class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-text&quot; data-lang=&quot;text&quot;&gt;  for i in /usr/local/var/postgres/*
  do
    running_ver=$(basename ${i})
    is_running=$(ps -few|egrep -- &amp;amp;quot;[p]ostgres.*-D.*${running_ver}&amp;amp;quot;)
    if [[ ! -z ${is_running} ]] ; then
      echo -n &amp;amp;quot;Stopping PostgreSQL ${running_ver}... &amp;amp;quot;
      /usr/local/opt/postgresql-${running_ver}/bin/pg_ctl \
        -D $i stop -mf &amp;amp;amp;&amp;amp;gt;/dev/null
      echo &amp;amp;quot;done!&amp;amp;quot;
    fi
  done

  echo -n &amp;amp;quot;Activating PostgreSQL ${ver}... &amp;amp;quot;
  brew unlink --force --overwrite postgresql-${ver} &amp;amp;amp;&amp;amp;gt;/dev/null
  brew link --force --overwrite postgresql-${ver} &amp;amp;amp;&amp;amp;gt;/dev/null
  echo &amp;amp;quot;done!&amp;amp;quot;

  export PGDATA=/usr/local/var/postgres/${ver}

  if [[ ! -d ${PGDATA} ]] ; then
    echo -n &amp;amp;quot;Initializing PostgreSQL ${ver} cluster... &amp;amp;quot;
    mkdir ${PGDATA}
    initdb -k ${PGDATA} &amp;amp;amp;&amp;amp;gt;/dev/null || initdb ${PGDATA} &amp;amp;amp;&amp;amp;gt;/dev/null
    echo &amp;amp;quot;done!&amp;amp;quot;
  fi
  echo -n &amp;amp;quot;Starting PostgreSQL ${ver}... &amp;amp;quot;
  pg_ctl -D ${PGDATA} start &amp;amp;amp;&amp;amp;gt;/dev/null
  echo &amp;amp;quot;done!&amp;amp;quot;
}
&lt;/code&gt;&lt;/pre&gt;&lt;/figure&gt;
&lt;p&gt;```&lt;/pre&gt;&lt;/noscript&gt;&lt;script src=&quot;https://gist.github.com/hunleyd/b27085662bea30f3b39de293a038b766.js&quot;&gt; &lt;/script&gt;&lt;/p&gt;

&lt;p&gt;and then simply call &lt;code&gt;pg 9.5&lt;/code&gt; to set PostgreSQL 9.5 as your &amp;#39;active&amp;#39; instance:&lt;/p&gt;
&lt;figure class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-bash&quot; data-lang=&quot;bash&quot;&gt;oug@Douglass-MacBook-Pro ~ ¬ª pg 9.5
Stopping PostgreSQL 9.4... done!
Activating PostgreSQL 9.5... done!
Initializing PostgreSQL 9.5 cluster... done!
Starting PostgreSQL 9.5... done!
doug@Douglass-MacBook-Pro ~ ¬ª
&lt;/code&gt;&lt;/pre&gt;&lt;/figure&gt;
&lt;p&gt;Restore your data:&lt;/p&gt;

&lt;p&gt;&lt;noscript&gt;&lt;pre&gt;404: Not Found
&lt;/pre&gt;&lt;/noscript&gt;&lt;script src=&quot;https://gist.github.com/ihunleyd/a54dab54b0b44b7e9fd05ca54cf5fb95.js&quot;&gt; &lt;/script&gt;&lt;/p&gt;

&lt;p&gt;and there you be. Ain&amp;#39;t it beautiful? :)&lt;/p&gt;
</description>
    <link>http://hunleyd.github.io/Getting-fancy-with-PostgreSQL-and-Homebrew/ </link>
    <pubDate>2016-11-10T09:58:15-05:00</pubDate>
    <guid isPermaLink="true">http://hunleyd.github.io/Getting-fancy-with-PostgreSQL-and-Homebrew/</guid>
   </item>
  
   <item>
    <title>PostgreSQL, Homebrew, and You</title>
    <description>&lt;p&gt;&lt;img src=&quot;http://cdn.curvve.com/wp-content/uploads/2013/09/homebrew_osx_logo.png&quot; border=0 align=left style=&quot;PADDING-RIGHT: 5px&quot;&gt;If you need to install &lt;a href=&quot;http://www.posatgresql.org&quot;&gt;PostgreSQL&lt;/a&gt; onto your Macbook, you have several options available to you nowadays. You could use the &lt;a href=&quot;https://bigsql.com/postgresql/installers.jsp&quot;&gt;BigSQL&lt;/a&gt; package, or you could use &lt;a href=&quot;http://postgresapp.com&quot;&gt;Postgres.app&lt;/a&gt;, or several others. However, if you&amp;#39;re a geek running OSX, you&amp;#39;ve probably already installed &lt;a href=&quot;http://brew.sh&quot;&gt;Homebrew&lt;/a&gt; and it has a wonderful PostgreSQL package. So let&amp;#39;s use it, shall we?&lt;/p&gt;

&lt;p&gt;I&amp;#39;m not going to walk you through installing Homebrew, so let&amp;#39;s just assume it&amp;#39;s already up and running and you&amp;#39;ve followed all the directions. At this point, you have &lt;code&gt;/usr/local/bin/&lt;/code&gt; in your &lt;code&gt;$PATH&lt;/code&gt; and &lt;code&gt;brew&lt;/code&gt; is up and running. So, let&amp;#39;s tell &lt;code&gt;brew&lt;/code&gt; to install PostgreSQL:&lt;/p&gt;
&lt;figure class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-text&quot; data-lang=&quot;text&quot;&gt;doug@Douglass-MacBook-Pro ~ ¬ª brew install postgresql
==&amp;gt; Downloading https://homebrew.bintray.com/bottles/postgresql-9.5.4_1.sierra.b
Already downloaded: /Users/doug/Library/Caches/Homebrew/postgresql-9.5.4_1.sierra.bottle.tar.gz
==&amp;gt; Pouring postgresql-9.5.4_1.sierra.bottle.tar.gz
==&amp;gt; Using the sandbox
==&amp;gt; /usr/local/Cellar/postgresql/9.5.4_1/bigsqln/initdb /usr/local/var/postgres
==&amp;gt; Caveats
If builds of PostgreSQL 9 are failing and you have version 8.x installed,
you may need to remove the previous version first. See:
  https://github.com/Homebrew/homebrew/issues/2510

To migrate existing data from a previous major version (pre-9.0) of PostgreSQL, see:
  https://www.postgresql.org/docs/9.5/static/upgrading.html

To migrate existing data from a previous minor versionn (9.0-9.4) of PostgreSQL, see:
  https://www.postgresql.org/docs/9.5/static/pgupgrade.html

  You will need your previous PostgreSQL installation from brew to perform `pg_upgrade`.
  Do not run `brew cleanup postgresql` until you have performed the migration.

To have launchd start postgresql now and restart at login:
  brew services start postgresql
Or, if you don&amp;#39;t want/need a background service you can just run:
  pg_ctl -D /usr/local/var/postgres start
==&amp;gt; Summary
üç∫  /usr/local/Cellar/postgresql/9.5.4_1: 3,147 files, 35M
&lt;/code&gt;&lt;/pre&gt;&lt;/figure&gt;
&lt;p&gt;As you can see, it downloaded the package, installed the binaries, and ran &lt;code&gt;initdb&lt;/code&gt; for us! As the output tells us, we can set PostgreSQL to auto-start when we login by issuing:&lt;/p&gt;
&lt;figure class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-bash&quot; data-lang=&quot;bash&quot;&gt;doug@Douglass-MacBook-Pro ~ ¬ª brew services start postgresql
==&amp;gt; Successfully started `postgresql` (label: homebrew.mxcl.postgresql)
&lt;/code&gt;&lt;/pre&gt;&lt;/figure&gt;
&lt;p&gt;And if you check your process listing, you can see that the cluster is up and running under your id:&lt;/p&gt;
&lt;figure class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-bash&quot; data-lang=&quot;bash&quot;&gt;doug@Douglass-MacBook-Pro ~ ¬ª ps -efw|grep postgres
  501  6808     1   0 11:03AM ??         0:00.02 /usr/local/opt/postgresql/bin/postgres -D /usr/local/var/postgres
  501  6817  6808   0 11:03AM ??         0:00.00 postgres: logger process
  501  6819  6808   0 11:03AM ??         0:00.00 postgres: checkpointer process
  501  6820  6808   0 11:03AM ??         0:00.00 postgres: writer process
  501  6821  6808   0 11:03AM ??         0:00.00 postgres: wal writer process
  501  6822  6808   0 11:03AM ??         0:00.00 postgres: autovacuum launcher process
  501  6823  6808   0 11:03AM ??         0:00.00 postgres: stats collector process
doug@Douglass-MacBook-Pro ~ ¬ª
&lt;/code&gt;&lt;/pre&gt;&lt;/figure&gt;
&lt;p&gt;And just like that, you have PostgreSQL installed and running! Set &lt;code&gt;$PGDATA&lt;/code&gt; to &lt;code&gt;/usr/local/var/postgres&lt;/code&gt; and you&amp;#39;re all set.&lt;/p&gt;

&lt;p&gt;Enjoy!&lt;/p&gt;
</description>
    <link>http://hunleyd.github.io/PostgreSQL-Homebrew-and-You/ </link>
    <pubDate>2016-11-04T09:30:09-04:00</pubDate>
    <guid isPermaLink="true">http://hunleyd.github.io/PostgreSQL-Homebrew-and-You/</guid>
   </item>
  
   <item>
    <title>Inaugural pgCMH mtg scheduled</title>
    <description>&lt;p&gt;&lt;img src=&quot;/images/pgCMH.png&quot; border=0 height=200 width=200 align=right style=&quot;PADDING_LEFT: 5px&quot;&gt; As announced on our &lt;a href=&quot;http://www.twitter.com/pgCMH&quot;&gt;Twitter&lt;/a&gt;, we&amp;#39;ve scheduled our inaugural meeting for Jan 24, 2017 at 1800 hrs. The folks at CoverMyMeds will graciously provide the meeting space (and parking garage) while OpenSCG is buying the pizza!&lt;/p&gt;

&lt;p&gt;At this first meeting, we&amp;#39;ll be discussing what you, the members, would like to get from the meetings, we&amp;#39;ll talk about future topics, and general organizational things. I know it&amp;#39;s not exciting, but I need everyone&amp;#39;s input to make this group something you get value from.&lt;/p&gt;

&lt;div class='jekyll-twitter-plugin'&gt;&lt;blockquote class=&quot;twitter-tweet&quot;&gt;&lt;p lang=&quot;en&quot; dir=&quot;ltr&quot;&gt;Our first mtg is happening on Jan 24 at &lt;a href=&quot;https://twitter.com/CoverMyMeds&quot;&gt;@covermymeds&lt;/a&gt; with &lt;a href=&quot;https://twitter.com/OpenSCG&quot;&gt;@openscg&lt;/a&gt; buying pizza. Bring a friend! RSVP at &lt;a href=&quot;https://t.co/600ZNbPV8e&quot;&gt;https://t.co/600ZNbPV8e&lt;/a&gt;&lt;/p&gt;&amp;mdash; pgCMH (@pgCMH) &lt;a href=&quot;https://twitter.com/pgCMH/status/788780137630216192&quot;&gt;October 19, 2016&lt;/a&gt;&lt;/blockquote&gt;
&lt;script async src=&quot;//platform.twitter.com/widgets.js&quot; charset=&quot;utf-8&quot;&gt;&lt;/script&gt;&lt;/div&gt;

&lt;p&gt;Please RSVP via the &lt;a href=&quot;https://www.meetup.com/postgresCMH/events/234969649/&quot;&gt;MeetUP event&lt;/a&gt; so we have sufficient food and drink!&lt;/p&gt;

&lt;p&gt;See you there!&lt;/p&gt;
</description>
    <link>http://hunleyd.github.io/Inaugural-pgCMH-mtg/ </link>
    <pubDate>2016-11-03T07:45:32-04:00</pubDate>
    <guid isPermaLink="true">http://hunleyd.github.io/Inaugural-pgCMH-mtg/</guid>
   </item>
  
   <item>
    <title>Announcing pgCMH</title>
    <description>&lt;p&gt;&lt;img src=&quot;/images/pgCMH.png&quot; border=0 height=200 width=200 align=right&gt;I&amp;#39;ve been kicking around the idea of founding a Columbus-based PostgreSQL User Group for a while now. I even went so far as to float the idea to people at &lt;a href=&quot;http://www.ohiolinux.org&quot;&gt;OLF&lt;/a&gt; in &amp;#39;14. After much hemming and hawing (and no one else stepping up in the interim), I&amp;#39;ve finally gone and done it.&lt;/p&gt;

&lt;p&gt;pgCMH is the name of my newly formed group, and we&amp;#39;re good to go. We&amp;#39;ve got our own Twitter (&lt;a href=&quot;http://www.twitter.com/pgCMH&quot;&gt;@pgCMH&lt;/a&gt;):&lt;/p&gt;

&lt;div class='jekyll-twitter-plugin'&gt;&lt;blockquote class=&quot;twitter-tweet&quot;&gt;&lt;p lang=&quot;en&quot; dir=&quot;ltr&quot;&gt;&lt;a href=&quot;https://twitter.com/hashtag/PostgreSQL?src=hash&quot;&gt;#PostgreSQL&lt;/a&gt; 9.6.1, 9.5.5, 9.4.10, 9.3.15, 9.2.19 and 9.1.24 Released! &lt;a href=&quot;https://t.co/RH27To33gh&quot;&gt;https://t.co/RH27To33gh&lt;/a&gt;&lt;/p&gt;&amp;mdash; pgCMH (@pgCMH) &lt;a href=&quot;https://twitter.com/pgCMH/status/791654418731065344&quot;&gt;October 27, 2016&lt;/a&gt;&lt;/blockquote&gt;
&lt;script async src=&quot;//platform.twitter.com/widgets.js&quot; charset=&quot;utf-8&quot;&gt;&lt;/script&gt;&lt;/div&gt;

&lt;p&gt;as well as our own &lt;a href=&quot;http://www.meetup.com/postgresCMH&quot;&gt;MeetUp&lt;/a&gt; page. We&amp;#39;ve got a sponsor providing food, and another providing the meeting location. Our first meeting will be in Jan, thanks to all the scheduling conflicts the upcoming holidays create.&lt;/p&gt;

&lt;p&gt;Watch this space for updates, follow our Twitter, and join the mailing list on MeetUp. I&amp;#39;d love to get your participation and input. Let&amp;#39;s make this group as wildly successful as we can!&lt;/p&gt;
</description>
    <link>http://hunleyd.github.io/Announcing-pgCMH/ </link>
    <pubDate>2016-10-31T07:35:22-04:00</pubDate>
    <guid isPermaLink="true">http://hunleyd.github.io/Announcing-pgCMH/</guid>
   </item>
  
   <item>
    <title>Incremental pgBadger</title>
    <description>&lt;p&gt;&lt;img src=&quot;https://dalibo.github.io/pgbadger/logo_pgbadger.png&quot; border=0 align=left&gt; You&amp;#39;re probably already running &lt;a href=&quot;https://dalibo.github.io/pgbadger/index.html&quot;&gt;pgBadger&lt;/a&gt; to monitor your PostgreSQL logs. However, you&amp;#39;re probably &lt;em&gt;not&lt;/em&gt; running it incrementally throughout the day. Most likely, you&amp;#39;ve setup a &lt;code&gt;cron.daily&lt;/code&gt; job that runs pgBadger against yesterday&amp;#39;s log(s). And that&amp;#39;s great. Except when you get the dreaded &amp;quot;what just happened on the db?&amp;quot; email. Are you going to wait until tonight&amp;#39;s normal run of pgBadger to see what happened? Are you going to run a &amp;#39;one off&amp;#39; pgBadger against today&amp;#39;s logfile and wait for it to process the &lt;em&gt;entire&lt;/em&gt; log? Or are you going to copy the log off somewhere, edit it to cut it down, and &lt;em&gt;then&lt;/em&gt; run pgBadger against this cut-down version (hoping you left enough in the log to see proper trending)?&lt;/p&gt;

&lt;p&gt;No, most likely you&amp;#39;re going to look at your actual monitoring tool that does real-time monitoring of your db and try to figure things out from there. You &lt;em&gt;are&lt;/em&gt; running some kind of db monitoring tool, right?&lt;/p&gt;

&lt;p&gt;However, let&amp;#39;s say that for, uh, reasons, you only have pgBadger at your disposal &lt;em&gt;right this instant&lt;/em&gt;. Well, if you were making use of pgBadger&amp;#39;s &lt;em&gt;incremental mode&lt;/em&gt; you could simply fire off the next scheduled run and it would only process those log entries that were new since the last run. So, for example, if you had a &lt;code&gt;cron.hourly&lt;/code&gt; run of pgBadger it would only process the last hour&amp;#39;s worth of entries to update today&amp;#39;s report. No waiting to process multiple hours of info that you don&amp;#39;t need, no editing of the logfile to remove things outside the window you care about, just run it and done.&lt;/p&gt;

&lt;p&gt;Sounds nice, right? So let&amp;#39;s set this up shall we? I&amp;#39;m assuming you&amp;#39;ve already setup &lt;code&gt;postgresql.conf&lt;/code&gt; appropriately, but if you haven&amp;#39;t please go that first. The pgBadger website has good documentation on how to do so. According to the docs:&lt;/p&gt;
&lt;figure class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-apache&quot; data-lang=&quot;apache&quot;&gt;-I | --incremental     : use incremental mode, reports will be generated by days in a separate directory, --outdir must be set.
&lt;/code&gt;&lt;/pre&gt;&lt;/figure&gt;
&lt;p&gt;is how we turn on incremental mode. You&amp;#39;ll note that we also need to specify an output dir:&lt;/p&gt;
&lt;figure class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-apache&quot; data-lang=&quot;apache&quot;&gt;-O | --outdir path     : directory where out file must be saved
&lt;/code&gt;&lt;/pre&gt;&lt;/figure&gt;
&lt;p&gt;I usually stick the pgBadger output into the &lt;code&gt;pg_log&lt;/code&gt; directory. In my mind, having the logs and the report on the logs next to each makes sense, but feel free to stick yours wherever.&lt;/p&gt;

&lt;p&gt;Finally, we probably don&amp;#39;t need pgBadger reports that are too old, and the docs say we can cull the cruft automatically:&lt;/p&gt;
&lt;figure class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-apache&quot; data-lang=&quot;apache&quot;&gt;-R | --retention N     : number of week to keep in incremental mode. Default to 0, disabled. Used to set the number of weel to keep in output directory. Older weeks and days directory are automatically removed.
&lt;/code&gt;&lt;/pre&gt;&lt;/figure&gt;
&lt;p&gt;(Ignore the typo, it&amp;#39;s that way in the code)&lt;/p&gt;

&lt;p&gt;On my servers, I have PostgreSQL setup to log into a different file for each day of the week, with automatic rotation and truncation:&lt;/p&gt;
&lt;figure class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-text&quot; data-lang=&quot;text&quot;&gt;log_filename = &amp;#39;postgresql-%a.log&amp;#39;
log_truncate_on_rotation = on
log_rotation_age = 1d
&lt;/code&gt;&lt;/pre&gt;&lt;/figure&gt;
&lt;p&gt;so my &lt;code&gt;cron.hourly&lt;/code&gt; pgBadger looks like:&lt;/p&gt;
&lt;figure class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-text&quot; data-lang=&quot;text&quot;&gt;pgbadger \
    -I \
    -O $PGDATA/pg_log \
    -R 12 \
    -q \
    $PGDATA/pg_log/postgresql-$(date --date yesterday +%a) \
    $PGDATA/pg_log/postgresql-$(date +%a)
&lt;/code&gt;&lt;/pre&gt;&lt;/figure&gt;
&lt;p&gt;which as you can see always feeds both yesterday&amp;#39;s and today&amp;#39;s log into pgBadger (since the cron runs at 2300 and then again at 0000, we need yesterday&amp;#39;s log to catch that last hour). Since we&amp;#39;re running in incremental mode, it knows &lt;em&gt;at every run&lt;/em&gt; where it left off in the files the last time and does a &lt;code&gt;seek&lt;/code&gt; to skip over that data. This cuts the run time down &lt;em&gt;significantly&lt;/em&gt; even with the PostgreSQL logging &lt;em&gt;cranked up&lt;/em&gt;. You can see it here:&lt;/p&gt;
&lt;figure class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-text&quot; data-lang=&quot;text&quot;&gt;...
DEBUG: Starting reading file postgresql-Wed.log...
DEBUG: Start parsing at offset 412677131 of file postgresql-Wed.log to 433543395
[======================&amp;gt;  ] Parsed 413815537 bytes of 433543395 (95.45%), queries
...
&lt;/code&gt;&lt;/pre&gt;&lt;/figure&gt;
&lt;p&gt;As you can see, it jumps right in at 95% of the file and only processes the newest 5%. In fact, this takes a mere 20 seconds:&lt;/p&gt;
&lt;figure class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-text&quot; data-lang=&quot;text&quot;&gt;statistics gathering took:20 wallclock secs (19.44 usr +  0.17 sys = 19.61 CPU)
&lt;/code&gt;&lt;/pre&gt;&lt;/figure&gt;
&lt;p&gt;on my overloaded Macbook!&lt;/p&gt;

&lt;p&gt;So there you have it. Not counting the time it takes you to &lt;code&gt;ssh&lt;/code&gt; to your server, it would have taken all of &lt;em&gt;20 seconds&lt;/em&gt; to have an updated report of what just happened on your database!&lt;/p&gt;

&lt;p&gt;Keep in mind, this is also with a &lt;em&gt;single thread&lt;/em&gt;. pgBadger has the ability to run multi-threaded. See the &lt;code&gt;--help&lt;/code&gt; for details.&lt;/p&gt;

&lt;p&gt;Enjoy!&lt;/p&gt;
</description>
    <link>http://hunleyd.github.io/Incremental-pgBadger/ </link>
    <pubDate>2016-10-26T10:46:09-04:00</pubDate>
    <guid isPermaLink="true">http://hunleyd.github.io/Incremental-pgBadger/</guid>
   </item>
  
   <item>
    <title>I'm syndicated</title>
    <description>&lt;p&gt;Someone at work thought it would be a good idea to give me access to the corporate blog so that I might &lt;a href=&quot;http://www.openscg.com/category/postgresql-blogs/doug-postgresql/&quot;&gt;post&lt;/a&gt; PostgreSQL-related things there and have them syndicted to &lt;a href=&quot;http://planet.postgresql.org/&quot;&gt;Planet PostgreSQL&lt;/a&gt;. So my PostgreSQL ramblings will show up there now instead of here. This should be fun!&lt;/p&gt;
</description>
    <link>http://hunleyd.github.io/Im-Syndicated/ </link>
    <pubDate>2016-10-08T11:19:57-04:00</pubDate>
    <guid isPermaLink="true">http://hunleyd.github.io/Im-Syndicated/</guid>
   </item>
  
 </channel>
</rss>
